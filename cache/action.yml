name: 'Smart Cache'
description: 'Intelligent cache wrapper that manages space before creating new caches'
author: 'ARM Software'

inputs:
  # Standard cache inputs (full compatibility)
  path:
    description: 'A list of files, directories, and wildcard patterns to cache and restore'
    required: true
  key:
    description: 'An explicit key for restoring and saving the cache'
    required: true
  restore-keys:
    description: 'An ordered list of keys to use for restoring stale cache if no cache hit occurred for key'
    required: false
  upload-chunk-size:
    description: 'The chunk size used to split up large files during upload, in bytes'
    required: false
  enableCrossOsArchive:
    description: 'An optional boolean when enabled, allows windows runners to save or restore caches that can be restored or saved respectively on other platforms'
    required: false
    default: 'false'
  fail-on-cache-miss:
    description: 'Fail the workflow if cache entry is not found'
    required: false
    default: 'false'
  lookup-only:
    description: 'Check if a cache entry exists for the given input(s) (key, restore-keys) without downloading the cache'
    required: false
    default: 'false'

  # Smart cache management inputs  
  max-cache-size:
    description: "Maximum total cache size in GB before cleanup (default: 8GB)"
    default: "8"
    required: false
  dry-run-cleanup:
    description: "If true, only show what would be cleaned without actually cleaning"
    default: "false"
    required: false

outputs:
  cache-hit:
    description: 'A boolean value to indicate an exact match was found for the primary key'
    value: ${{ steps.cache.outputs.cache-hit }}
  cache-primary-key:
    description: 'Cache primary key passed in the input'
    value: ${{ steps.cache.outputs.cache-primary-key }}
  cache-matched-key:
    description: 'Key of the cache that was restored, it could either be the primary key on cache-hit or a partial/complete match of one of the restore keys'
    value: ${{ steps.cache.outputs.cache-matched-key }}
  cleanup-performed:
    description: 'Whether cleanup was performed before caching'
    value: ${{ steps.pre-cleanup.outputs.cleanup-performed || 'false' }}
  space-freed-mb:
    description: 'Amount of space freed during cleanup in MB'
    value: ${{ steps.pre-cleanup.outputs.space-freed-mb || '0' }}
  repo-cleanup-performed:
    description: 'Whether repository-level cleanup was performed'
    value: ${{ steps.repo-cleanup.outputs.repo-cleanup-performed || 'false' }}
  repo-space-freed-mb:
    description: 'Amount of space freed during repository cleanup in MB'
    value: ${{ steps.repo-cleanup.outputs.repo-space-freed-mb || '0' }}

runs:
  using: 'composite'
  steps:
    - name: Check if cache exists
      id: cache-exists
      uses: actions/cache@0057852bfaa89a56745cba8c7296529d2fc39830 # v4.3.0
      with:
        path: ${{ inputs.path }}
        key: ${{ inputs.key }}
        restore-keys: ${{ inputs.restore-keys }}
        lookup-only: true
      continue-on-error: true

    - name: Determine cache strategy
      id: cache-strategy
      shell: bash
      run: |
        echo "üîç Determining cache strategy..."
        
        # If user requested lookup-only, just use the existing check
        if [[ "${{ inputs.lookup-only }}" == "true" ]]; then
          echo "cache-needed=true" >> "$GITHUB_OUTPUT"
          echo "cache-exists=${{ steps.cache-exists.outputs.cache-hit || 'false' }}" >> "$GITHUB_OUTPUT"
          echo "reason=lookup-only-requested" >> "$GITHUB_OUTPUT"
          echo "‚úÖ Lookup-only mode requested"
          exit 0
        fi
        
        # Check if cache already exists
        if [[ "${{ steps.cache-exists.outputs.cache-hit }}" == "true" ]]; then
          echo "cache-needed=true" >> "$GITHUB_OUTPUT"
          echo "cache-exists=true" >> "$GITHUB_OUTPUT"
          echo "reason=cache-exists-restore-only" >> "$GITHUB_OUTPUT"
          echo "‚úÖ Cache exists - will restore without cleanup"
          exit 0
        fi
        
        # Cache doesn't exist, check if paths exist for new cache
        echo "üîç No existing cache found. Checking paths for new cache..."
        
        cache_needed=false
        missing_paths=""
        
        # Cross-platform compatible multiline input handling
        path_input="${{ inputs.path }}"
        
        # Convert to array using while loop (works on all platforms)
        path_array=()
        while IFS= read -r line; do
          [[ -n "$line" ]] && path_array+=("$line")
        done <<< "$path_input"
        
        for path in "${path_array[@]}"; do
          if [[ -n "$path" ]]; then
            # Cross-platform whitespace trimming
            path=$(echo "$path" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            
            if [[ -e "$path" ]] || ls "$path" >/dev/null 2>&1; then
              cache_needed=true
              echo "  üìÅ Found: $path"
            else
              missing_paths="$missing_paths $path"
              echo "  ‚ùå Missing: $path"
            fi
          fi
        done
        
        if [[ "$cache_needed" == "true" ]]; then
          echo "cache-needed=true" >> "$GITHUB_OUTPUT"
          echo "cache-exists=false" >> "$GITHUB_OUTPUT"
          echo "reason=paths-exist-new-cache" >> "$GITHUB_OUTPUT"
          echo "‚úÖ Paths found - will create new cache"
        else
          echo "cache-needed=false" >> "$GITHUB_OUTPUT"
          echo "cache-exists=false" >> "$GITHUB_OUTPUT"
          echo "reason=no-paths-found" >> "$GITHUB_OUTPUT"
          echo "‚ö†Ô∏è  No paths found to cache: $missing_paths"
        fi

    - name: Estimate cache size
      id: estimate-size
      if: steps.cache-strategy.outputs.cache-needed == 'true' && steps.cache-strategy.outputs.cache-exists == 'false'
      shell: bash
      run: |
        echo "üìè Estimating cache size for new cache..."
        
        # Calculate actual size of paths with cross-platform compatibility
        total_size=0
        
        # Cross-platform compatible multiline input handling
        path_input="${{ inputs.path }}"
        
        # Convert to array using while loop
        path_array=()
        while IFS= read -r line; do
          [[ -n "$line" ]] && path_array+=("$line")
        done <<< "$path_input"
        
        for path in "${path_array[@]}"; do
          if [[ -n "$path" ]]; then
            path=$(echo "$path" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            if [[ -e "$path" ]]; then
              # Cross-platform size calculation using du
              size=$(du -sm "$path" 2>/dev/null | cut -f1 || echo "0")
              total_size=$((total_size + size))
              echo "  üìÅ $path: ${size}MB"
            fi
          fi
        done
        
        # Add 25% buffer for compression variations and metadata
        estimated_mb=$((total_size + (total_size * 25 / 100)))
        if [[ $estimated_mb -eq 0 && $total_size -gt 0 ]]; then
          estimated_mb=1  # Minimum 1MB estimate
        fi
        
        echo "  Calculated size: ${total_size}MB"
        echo "  With buffer (25%): ${estimated_mb}MB"
        
        echo "estimated-size-mb=$estimated_mb" >> "$GITHUB_OUTPUT"
        echo "‚úÖ Estimated cache size: ${estimated_mb}MB"

    - name: Pre-cache cleanup
      id: pre-cleanup
      if: steps.cache-strategy.outputs.cache-needed == 'true' && steps.cache-strategy.outputs.cache-exists == 'false'
      shell: bash
      env:
        GITHUB_TOKEN: ${{ github.token }}
        MAX_SIZE_GB: ${{ inputs.max-cache-size }}
        ESTIMATED_SIZE_MB: ${{ steps.estimate-size.outputs.estimated-size-mb }}
        CLEANUP_THRESHOLD: "80"
        CURRENT_KEY: ${{ inputs.key }}
        DRY_RUN: ${{ inputs.dry-run-cleanup }}
      run: |
        echo "üßπ Starting pre-cache cleanup analysis (LRU strategy)..."
        
        # Initialize outputs
        echo "cleanup-performed=false" >> "$GITHUB_OUTPUT"
        echo "space-freed-mb=0" >> "$GITHUB_OUTPUT"
        
        # Check if gh CLI is available
        if ! command -v gh &> /dev/null; then
          echo "‚ö†Ô∏è  GitHub CLI not found. Skipping cleanup."
          exit 0
        fi
        
        # Check if jq is available
        if ! command -v jq &> /dev/null; then
          echo "‚ö†Ô∏è  jq not found. Skipping cleanup."
          exit 0
        fi
        
        # Cross-platform function to format bytes to human readable
        format_bytes() {
          local bytes=$1
          if (( bytes >= 1073741824 )); then
            echo "$(( bytes / 1073741824 ))GB"
          elif (( bytes >= 1048576 )); then
            echo "$(( bytes / 1048576 ))MB"
          elif (( bytes >= 1024 )); then
            echo "$(( bytes / 1024 ))KB"
          else
            echo "${bytes}B"
          fi
        }
        
        # Cross-platform function to decode base64
        decode_base64() {
          if command -v base64 >/dev/null 2>&1; then
            # Try GNU coreutils first (Linux)
            if base64 --help 2>/dev/null | grep -q -- '--decode'; then
              echo "$1" | base64 --decode 2>/dev/null
            else
              # macOS and Windows (via Git Bash)
              echo "$1" | base64 -d 2>/dev/null
            fi
          else
            echo "base64 command not found" >&2
            return 1
          fi
        }
        
        # Function to retry GitHub API calls
        retry_gh_api() {
          local retries=3
          local delay=2
          local cmd=("$@")
          
          for ((i=0; i<retries; i++)); do
            if "${cmd[@]}" 2>/dev/null; then
              return 0
            fi
            if [[ $i -lt $((retries-1)) ]]; then
              echo "  API call failed, retrying in ${delay}s..."
              sleep $delay
              delay=$((delay * 2))
            fi
          done
          return 1
        }
        
        # Get current cache status with retry
        echo "üìã Analyzing current cache usage..."
        
        cache_list=$(retry_gh_api gh api "repos/${{ github.repository }}/actions/caches" --paginate \
          -q '.actions_caches[] | {key: .key, size_in_bytes: .size_in_bytes, created_at: .created_at, last_accessed_at: .last_accessed_at, id: .id}' || echo "")
        
        if [[ -z "$cache_list" ]]; then
          echo "‚úÖ No existing caches found or API unavailable. No cleanup needed."
          exit 0
        fi
        
        # Calculate current total size
        total_size=0
        cache_count=0
        while IFS= read -r cache; do
          if [[ -n "$cache" ]]; then
            size=$(echo "$cache" | jq -r '.size_in_bytes // 0' 2>/dev/null || echo "0")
            total_size=$((total_size + size))
            cache_count=$((cache_count + 1))
          fi
        done <<< "$cache_list"
        
        # Cross-platform arithmetic (avoiding floating point)
        max_size_bytes=$((MAX_SIZE_GB * 1024 * 1024 * 1024))
        threshold_bytes=$((max_size_bytes * CLEANUP_THRESHOLD / 100))
        estimated_new_size_bytes=$((${ESTIMATED_SIZE_MB:-0} * 1024 * 1024))
        projected_size=$((total_size + estimated_new_size_bytes))
        
        echo "üìä Cache Analysis:"
        echo "  Current caches: $cache_count"
        echo "  Current total size: $(format_bytes $total_size)"
        echo "  Maximum allowed: $(format_bytes $max_size_bytes)"
        echo "  Cleanup threshold (80%): $(format_bytes $threshold_bytes)"
        echo "  Estimated new cache: $(format_bytes $estimated_new_size_bytes)"
        echo "  Projected total: $(format_bytes $projected_size)"
        echo ""
        
        # Determine if cleanup is needed
        cleanup_needed=false
        cleanup_reason=""
        
        if [[ $projected_size -gt $max_size_bytes ]]; then
          cleanup_needed=true
          cleanup_reason="projected size exceeds maximum"
        elif [[ $total_size -gt $threshold_bytes ]]; then
          cleanup_needed=true
          cleanup_reason="current size exceeds threshold"
        fi
        
        if [[ "$cleanup_needed" != "true" ]]; then
          echo "‚úÖ No cleanup needed - $cleanup_reason"
          exit 0
        fi
        
        echo "üóëÔ∏è  Cleanup needed: $cleanup_reason"
        
        # Filter caches for cleanup (exclude current key)
        cleanup_candidates=$(echo "$cache_list" | jq -s --arg key "$CURRENT_KEY" \
          'map(select(.key != $key))' 2>/dev/null || echo "[]")
        
        candidate_count=$(echo "$cleanup_candidates" | jq '. | length' 2>/dev/null || echo "0")
        
        if [[ $candidate_count -eq 0 ]]; then
          echo "‚ö†Ô∏è  No cleanup candidates found (excluding current key)"
          exit 0
        fi
        
        # Sort candidates by LRU (Least Recently Used)
        sorted_candidates=$(echo "$cleanup_candidates" | jq 'sort_by(.last_accessed_at // .created_at)' 2>/dev/null || echo "[]")
        
        echo "üìã Found $candidate_count cleanup candidates using LRU strategy"
        
        # Calculate how much space we need to free
        space_needed=$((projected_size - threshold_bytes))
        if [[ $space_needed -lt 0 ]]; then
          space_needed=0
        fi
        
        echo "üéØ Target: Free at least $(format_bytes $space_needed)"
        
        # Process deletions with cross-platform variable scope handling
        space_freed=0
        deleted_count=0
        
        # Create temporary file for cross-platform variable persistence
        temp_dir="${RUNNER_TEMP:-/tmp}"
        temp_file="$temp_dir/cache_cleanup_stats_$$"
        echo "0,0" > "$temp_file"
        
        # Process each candidate
        candidate_list=$(echo "$sorted_candidates" | jq -r '.[]? | @base64' 2>/dev/null || true)
        
        while IFS= read -r cache_b64; do
          [[ -z "$cache_b64" ]] && continue
          
          # Read current stats from temp file
          if [[ -f "$temp_file" ]]; then
            current_stats=$(cat "$temp_file" 2>/dev/null || echo "0,0")
            space_freed=$(echo "$current_stats" | cut -d',' -f1)
            deleted_count=$(echo "$current_stats" | cut -d',' -f2)
          fi
          
          if [[ $space_freed -ge $space_needed ]]; then
            echo "‚úÖ Cleanup goals met"
            break
          fi
          
          cache=$(decode_base64 "$cache_b64" || continue)
          cache_id=$(echo "$cache" | jq -r '.id // empty' 2>/dev/null || continue)
          key=$(echo "$cache" | jq -r '.key // empty' 2>/dev/null || continue)
          size=$(echo "$cache" | jq -r '.size_in_bytes // 0' 2>/dev/null || echo "0")
          last_accessed=$(echo "$cache" | jq -r '.last_accessed_at // .created_at // "unknown"' 2>/dev/null || echo "unknown")
          
          if [[ -z "$cache_id" || -z "$key" ]]; then
            continue
          fi
          
          if [[ "$DRY_RUN" == "true" ]]; then
            echo "  [DRY RUN] Would delete: $key ($(format_bytes $size), last accessed: $last_accessed)"
            space_freed=$((space_freed + size))
            deleted_count=$((deleted_count + 1))
          else
            echo "  üóëÔ∏è Deleting: $key ($(format_bytes $size), last accessed: $last_accessed)"
            
            if retry_gh_api gh api "repos/${{ github.repository }}/actions/caches/$cache_id" -X DELETE; then
              echo "    ‚úÖ Deleted successfully"
              space_freed=$((space_freed + size))
              deleted_count=$((deleted_count + 1))
            else
              echo "    ‚ùå Failed to delete cache $cache_id"
            fi
          fi
          
          # Write updated stats to temp file
          echo "$space_freed,$deleted_count" > "$temp_file"
          
        done <<< "$candidate_list"
        
        # Read final stats from temp file
        if [[ -f "$temp_file" ]]; then
          final_stats=$(cat "$temp_file" 2>/dev/null || echo "0,0")
          space_freed=$(echo "$final_stats" | cut -d',' -f1)
          deleted_count=$(echo "$final_stats" | cut -d',' -f2)
          rm -f "$temp_file" 2>/dev/null || true
        fi
        
        # Update outputs
        space_freed_mb=$((space_freed / 1024 / 1024))
        if [[ $deleted_count -gt 0 ]]; then
          echo "cleanup-performed=true" >> "$GITHUB_OUTPUT"
        fi
        echo "space-freed-mb=$space_freed_mb" >> "$GITHUB_OUTPUT"
        
        # Final verification
        final_projected_size=$((total_size - space_freed + estimated_new_size_bytes))
        
        echo ""
        if [[ "$DRY_RUN" == "true" ]]; then
          echo "üîç Dry run completed. Would have freed $(format_bytes $space_freed) from $deleted_count caches"
          echo "  Projected size after cleanup: $(format_bytes $final_projected_size)"
        else
          echo "‚úÖ Cleanup completed!"
          echo "  Deleted caches: $deleted_count"
          echo "  Space freed: $(format_bytes $space_freed)"
          echo "  Final projected size: $(format_bytes $final_projected_size)"
          
          if [[ $final_projected_size -gt $max_size_bytes ]]; then
            echo "‚ö†Ô∏è  Warning: Projected size may still exceed limit after cleanup"
          else
            echo "‚úÖ New cache will fit within size limits"
          fi
        fi

    - name: Repository cache health check and cleanup
      id: repo-cleanup
      shell: bash
      env:
        GITHUB_TOKEN: ${{ github.token }}
        MAX_SIZE_GB: ${{ inputs.max-cache-size }}
        CLEANUP_THRESHOLD: "80"
        CURRENT_KEY: ${{ inputs.key }}
        DRY_RUN: ${{ inputs.dry-run-cleanup }}
      run: |
        echo "üè• Checking repository cache health..."
        
        # Initialize outputs
        echo "repo-cleanup-performed=false" >> "$GITHUB_OUTPUT"
        echo "repo-space-freed-mb=0" >> "$GITHUB_OUTPUT"
        
        # Check if tools are available
        if ! command -v gh &> /dev/null; then
          echo "‚ö†Ô∏è  GitHub CLI not found. Skipping repository cleanup."
          exit 0
        fi
        
        if ! command -v jq &> /dev/null; then
          echo "‚ö†Ô∏è  jq not found. Skipping repository cleanup."
          exit 0
        fi
        
        # Cross-platform function to format bytes to human readable
        format_bytes() {
          local bytes=$1
          if (( bytes >= 1073741824 )); then
            echo "$(( bytes / 1073741824 ))GB"
          elif (( bytes >= 1048576 )); then
            echo "$(( bytes / 1048576 ))MB"
          elif (( bytes >= 1024 )); then
            echo "$(( bytes / 1024 ))KB"
          else
            echo "${bytes}B"
          fi
        }
        
        # Cross-platform function to decode base64
        decode_base64() {
          if command -v base64 >/dev/null 2>&1; then
            if base64 --help 2>/dev/null | grep -q -- '--decode'; then
              echo "$1" | base64 --decode 2>/dev/null
            else
              echo "$1" | base64 -d 2>/dev/null
            fi
          else
            echo "base64 command not found" >&2
            return 1
          fi
        }
        
        # Function to retry GitHub API calls
        retry_gh_api() {
          local retries=3
          local delay=2
          local cmd=("$@")
          
          for ((i=0; i<retries; i++)); do
            if "${cmd[@]}" 2>/dev/null; then
              return 0
            fi
            if [[ $i -lt $((retries-1)) ]]; then
              echo "  API call failed, retrying in ${delay}s..."
              sleep $delay
              delay=$((delay * 2))
            fi
          done
          return 1
        }
        
        # Get current cache status
        echo "üìã Analyzing repository cache usage..."
        
        cache_list=$(retry_gh_api gh api "repos/${{ github.repository }}/actions/caches" --paginate \
          -q '.actions_caches[] | {key: .key, size_in_bytes: .size_in_bytes, created_at: .created_at, last_accessed_at: .last_accessed_at, id: .id}' || echo "")
        
        if [[ -z "$cache_list" ]]; then
          echo "‚úÖ No existing caches found or API unavailable. No cleanup needed."
          exit 0
        fi
        
        # Calculate current total repository cache size
        total_size=0
        cache_count=0
        while IFS= read -r cache; do
          if [[ -n "$cache" ]]; then
            size=$(echo "$cache" | jq -r '.size_in_bytes // 0' 2>/dev/null || echo "0")
            total_size=$((total_size + size))
            cache_count=$((cache_count + 1))
          fi
        done <<< "$cache_list"
        
        # Calculate size limits
        max_size_bytes=$((MAX_SIZE_GB * 1024 * 1024 * 1024))
        threshold_bytes=$((max_size_bytes * CLEANUP_THRESHOLD / 100))
        
        echo "üìä Repository Cache Analysis:"
        echo "  Total caches: $cache_count"
        echo "  Current total size: $(format_bytes $total_size)"
        echo "  Maximum allowed: $(format_bytes $max_size_bytes)"
        echo "  Cleanup threshold (80%): $(format_bytes $threshold_bytes)"
        echo ""
        
        # Determine if cleanup is needed (regardless of cache hit status)
        cleanup_needed=false
        cleanup_reason=""
        
        if [[ $total_size -gt $max_size_bytes ]]; then
          cleanup_needed=true
          cleanup_reason="repository cache size exceeds maximum limit"
        elif [[ $total_size -gt $threshold_bytes ]]; then
          cleanup_needed=true
          cleanup_reason="repository cache size exceeds 80% threshold"
        fi
        
        if [[ "$cleanup_needed" != "true" ]]; then
          echo "‚úÖ Repository cache size is healthy - $cleanup_reason"
          exit 0
        fi
        
        echo "üö® Repository cleanup needed: $cleanup_reason"
        
        # Filter caches for cleanup (exclude current key to preserve it)
        cleanup_candidates=$(echo "$cache_list" | jq -s --arg key "$CURRENT_KEY" \
          'map(select(.key != $key))' 2>/dev/null || echo "[]")
        
        candidate_count=$(echo "$cleanup_candidates" | jq '. | length' 2>/dev/null || echo "0")
        
        if [[ $candidate_count -eq 0 ]]; then
          echo "‚ö†Ô∏è  No cleanup candidates found (all caches match current key)"
          exit 0
        fi
        
        # Sort candidates by LRU (Least Recently Used)
        sorted_candidates=$(echo "$cleanup_candidates" | jq 'sort_by(.last_accessed_at // .created_at)' 2>/dev/null || echo "[]")
        
        echo "üìã Found $candidate_count cleanup candidates using LRU strategy"
        
        # Calculate how much space we need to free to get under threshold
        space_needed=$((total_size - threshold_bytes))
        if [[ $space_needed -lt 0 ]]; then
          space_needed=0
        fi
        
        echo "üéØ Target: Free at least $(format_bytes $space_needed) to get under 80% threshold"
        
        # Process deletions
        space_freed=0
        deleted_count=0
        
        # Create temporary file for cross-platform variable persistence
        temp_dir="${RUNNER_TEMP:-/tmp}"
        temp_file="$temp_dir/repo_cleanup_stats_$$"
        echo "0,0" > "$temp_file"
        
        # Process each candidate
        candidate_list=$(echo "$sorted_candidates" | jq -r '.[]? | @base64' 2>/dev/null || true)
        
        while IFS= read -r cache_b64; do
          [[ -z "$cache_b64" ]] && continue
          
          # Read current stats from temp file
          if [[ -f "$temp_file" ]]; then
            current_stats=$(cat "$temp_file" 2>/dev/null || echo "0,0")
            space_freed=$(echo "$current_stats" | cut -d',' -f1)
            deleted_count=$(echo "$current_stats" | cut -d',' -f2)
          fi
          
          if [[ $space_freed -ge $space_needed ]]; then
            echo "‚úÖ Repository cleanup goals met"
            break
          fi
          
          cache=$(decode_base64 "$cache_b64" || continue)
          cache_id=$(echo "$cache" | jq -r '.id // empty' 2>/dev/null || continue)
          key=$(echo "$cache" | jq -r '.key // empty' 2>/dev/null || continue)
          size=$(echo "$cache" | jq -r '.size_in_bytes // 0' 2>/dev/null || echo "0")
          last_accessed=$(echo "$cache" | jq -r '.last_accessed_at // .created_at // "unknown"' 2>/dev/null || echo "unknown")
          
          if [[ -z "$cache_id" || -z "$key" ]]; then
            continue
          fi
          
          if [[ "$DRY_RUN" == "true" ]]; then
            echo "  [DRY RUN] Would delete: $key ($(format_bytes $size), last accessed: $last_accessed)"
            space_freed=$((space_freed + size))
            deleted_count=$((deleted_count + 1))
          else
            echo "  üóëÔ∏è Deleting: $key ($(format_bytes $size), last accessed: $last_accessed)"
            
            if retry_gh_api gh api "repos/${{ github.repository }}/actions/caches/$cache_id" -X DELETE; then
              echo "    ‚úÖ Deleted successfully"
              space_freed=$((space_freed + size))
              deleted_count=$((deleted_count + 1))
            else
              echo "    ‚ùå Failed to delete cache $cache_id"
            fi
          fi
          
          # Write updated stats to temp file
          echo "$space_freed,$deleted_count" > "$temp_file"
          
        done <<< "$candidate_list"
        
        # Read final stats from temp file
        if [[ -f "$temp_file" ]]; then
          final_stats=$(cat "$temp_file" 2>/dev/null || echo "0,0")
          space_freed=$(echo "$final_stats" | cut -d',' -f1)
          deleted_count=$(echo "$final_stats" | cut -d',' -f2)
          rm -f "$temp_file" 2>/dev/null || true
        fi
        
        # Update outputs
        space_freed_mb=$((space_freed / 1024 / 1024))
        if [[ $deleted_count -gt 0 ]]; then
          echo "repo-cleanup-performed=true" >> "$GITHUB_OUTPUT"
        fi
        echo "repo-space-freed-mb=$space_freed_mb" >> "$GITHUB_OUTPUT"
        
        # Final status
        final_size=$((total_size - space_freed))
        
        echo ""
        if [[ "$DRY_RUN" == "true" ]]; then
          echo "üîç Repository cleanup dry run completed"
          echo "  Would have freed: $(format_bytes $space_freed) from $deleted_count caches"
          echo "  Repository size after cleanup: $(format_bytes $final_size)"
        else
          echo "‚úÖ Repository cleanup completed!"
          echo "  Deleted caches: $deleted_count"
          echo "  Space freed: $(format_bytes $space_freed)"
          echo "  New repository cache size: $(format_bytes $final_size)"
          
          if [[ $final_size -gt $max_size_bytes ]]; then
            echo "‚ö†Ô∏è  Warning: Repository cache size still exceeds limit"
            echo "üí° Consider lowering max-cache-size or running more aggressive cleanup"
          else
            echo "‚úÖ Repository cache size is now within limits"
          fi
        fi

    - name: Cache action
      id: cache
      if: steps.cache-strategy.outputs.cache-needed == 'true'
      uses: actions/cache@0057852bfaa89a56745cba8c7296529d2fc39830 # v4.3.0
      with:
        path: ${{ inputs.path }}
        key: ${{ inputs.key }}
        restore-keys: ${{ inputs.restore-keys }}
        upload-chunk-size: ${{ inputs.upload-chunk-size }}
        enableCrossOsArchive: ${{ inputs.enableCrossOsArchive }}
        fail-on-cache-miss: ${{ inputs.fail-on-cache-miss }}
        lookup-only: ${{ inputs.lookup-only }}

    - name: Cache operation summary
      if: always()
      shell: bash
      run: |
        echo "## üì¶ Smart Cache Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        # Repository cleanup status (always show if performed)
        if [[ "${{ steps.repo-cleanup.outputs.repo-cleanup-performed }}" == "true" ]]; then
          echo "üè• **Repository Cleanup Performed**" >> $GITHUB_STEP_SUMMARY
          echo "- **Space Freed:** ${{ steps.repo-cleanup.outputs.repo-space-freed-mb }}MB using LRU strategy" >> $GITHUB_STEP_SUMMARY
          echo "- **Reason:** Repository cache size exceeded limits" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
        fi
        
        if [[ "${{ steps.cache-strategy.outputs.cache-needed }}" == "true" ]]; then
          echo "‚úÖ **Cache operation performed**" >> $GITHUB_STEP_SUMMARY
          echo "- **Key:** \`${{ inputs.key }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Cache Hit:** ${{ steps.cache.outputs.cache-hit || 'N/A' }}" >> $GITHUB_STEP_SUMMARY
          
          if [[ -n "${{ steps.cache.outputs.cache-matched-key }}" ]]; then
            echo "- **Matched Key:** \`${{ steps.cache.outputs.cache-matched-key }}\`" >> $GITHUB_STEP_SUMMARY
          fi
          
          if [[ "${{ steps.cache-strategy.outputs.cache-exists }}" == "true" ]]; then
            echo "- **Cache Status:** Restored existing cache" >> $GITHUB_STEP_SUMMARY
          elif [[ "${{ steps.pre-cleanup.outputs.cleanup-performed }}" == "true" ]]; then
            echo "- **Pre-cleanup:** ‚úÖ Freed ${{ steps.pre-cleanup.outputs.space-freed-mb }}MB for new cache" >> $GITHUB_STEP_SUMMARY
          fi
          
          if [[ -n "${{ steps.estimate-size.outputs.estimated-size-mb }}" ]]; then
            echo "- **Estimated Size:** ${{ steps.estimate-size.outputs.estimated-size-mb }}MB" >> $GITHUB_STEP_SUMMARY
          fi
        else
          echo "‚è≠Ô∏è **Cache operation skipped**" >> $GITHUB_STEP_SUMMARY
          echo "- **Reason:** ${{ steps.cache-strategy.outputs.reason }}" >> $GITHUB_STEP_SUMMARY
        fi
